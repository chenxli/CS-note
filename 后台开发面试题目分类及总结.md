## 后台开发面试题目分类及总结

### C++问题

1.  C++11特性
    - 自动类型推导 auto
    - lambda匿名函数
    - for each遍历元素
    - {}初始化 vector
    - 右值引用(move)
    - final禁止虚函数被重写/禁止类被继承，override显式地重写虚函数
    - nullptr（NULL二义性）
    - 断言语句 assert
    - 线程库、智能指针，正则表达式；
    - 增强的元组，pair只是二元组，tuple是变长的。
    - 哈希表，其实就是unordered_map,unordered_set, unordered_multiset, unordered_multimap,查询和插入都是O(1)
    - default和delete显式地指定和禁止编译器为类自动生成一些方法的行为。
    - long long int
    
2. C++内存模型

   分成五个区，分别是堆、栈、自由存储区、全局/静态存储区，常量存储区

   - 栈：编译器分配，保存局部变量、函数参数等；

   - 堆：new分配的内存块，由程序员释放，如果没有手动释放，操作系统会在程序结束后自动回收

   - 自由存储区：malloc分配的内存块

     堆/栈的区别：

     - 管理方式不同
     - 空间大小不同
     - 能否产生碎片不同
     - 生长方向不同
     - 分配方式不同：堆只有动态，栈有静态和动态
     - 分配效率不同

3. STL allocator实现

4. C++ 四种强制类型转换
   * const_cast 
     - 常量指针被转化成非常量的指针，并且仍然指向原来的对象；
     - 常量引用被转换成非常量的引用，并且仍然指向原来的对象；
     - const_cast一般用于修改指针，如const char* p形式
   * static_cast
     - static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。
     - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
     - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。
     - static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)
     - 在c++ primer 中说道：c++ 的任何的隐式转换都是使用 *static_cast* 来实现。
   * dynamic_cast
     - *dynamic_cast*强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.
   *  reinterpret_cast
     - reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！
     - reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。

5. static 关键字的用法
   - 面向过程设计中的static
     - 静态全局变量：该变量在全局数据区分配内存；未经初始化的静态全局变量会被程序自动初始化为0；静态全局变量在声明它的整个文件是可见的，而在文件之外是不可见的。
     - 静态局部变量：该变量在全局数据区分配内存；静态局部变量在程序执行到该对象的声明处时被首次初始化，及以后的函数调用不再进行初始化；静态局部变量一般在声明初始化，如果没有显式初始化，会被程序自动初始化为0；始终驻留在全局数据区，直到程序运行结束。
     - 静态函数：不能被其他文件所用；其他文件中可以定义相同名字的函数，不会发生冲突。
   - 面向对象的static
     - 静态数据成员：所有对象共有；在全局数据区；不属于特定的类的对象，在没有产生类对象时其作用域就可见；静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其他全局名字冲突的可能性；可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能。
     - 静态成员函数：静态成员函数不能访问非静态成员函数和非静态数据成员

6. 继承方式

   无论哪种继承，父类的私有成员子类都不能直接访问，只能通过其他可以直接访问的方法进行访问。

   protected不允许外部访问，可以给派生类直接访问；跟private差不多，只是在继承的时候有区别。

   public继承：父类的public protected private成员到了子类还是一样，子类对象只能访问public

   protected继承：子类可以访问父类的public和protected成员，这些成员到了子类变成了protected和private，子类对象不能直接访问。

   private继承：子类可以访问父类的public和protected成员，这些成员到了子类变成了priavte，子类对象不能直接访问。

7. C++程序 编译、链接

   源程序 通过编译得到 对象文件（.o文件)， 再通过链接得到可执行程序；

   > 命令：
   >
   > g++ -C main.cpp
   >
   > g++ -C other.cpp
   >
   > //查看目标文件里需要的外部函数
   >
   > nm -C mian.o
   >
   > //链接
   >
   > g++ main.o other.o
   >
   > ./a.out

8. 析构为什么一般定义成虚函数？

   避免子类内存得不到正确地释放。

9. C++20新特性

   - Ranges
   - mudules

10. Go 语言与CPP与python区别

    Go、CPP是静态类型和编译型

    go原生并发编程

11. C++的虚函数是什么

    为了实现多态，让子类可以重新定义自己的行为，否则就是继承父类的行为。

12. 

### Linux系统

1. 线程和进程的区别

   进程是资源分配的最小单位；线程是CPU调度的最小单位。

   做个简单的比喻：进程=火车，线程=车厢

   - 线程在进程下行进（单纯的车厢无法运行）
   - 一个进程可以包含多个线程（一辆火车可以有多个车厢）
   - 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
   - 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
   - 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
   - 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
   - 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
   - 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
   - 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

2. 协程和线程区别

   协程是“轻量级的线程”，上下文切换开销比线程小，不需要从用户态转到内核态。

3. 进程空间分布

4. 堆和栈的区别

   - 堆和栈是内存分区中两个部分。栈区是由编译器自动分配和释放，存放函数的参数值，局部变量的值等；堆区一般有程序员分配释放，若程序员不释放，程序结束后可能由OS回收。

   - 申请方式：堆由程序员自己申请并指明大小，在C中malloc函数，如p1 = (char*)malloc(10);栈由系统自动分配，如声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间。

   - 申请后系统的响应：栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则         将报异常提示栈溢出。堆区：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大 小，系统会自动的将多余的那部分重新放入空闲链表中。

   - 申请大小的限制：栈区：在Windows下,栈是向低地址扩展的数据结 构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是 一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

   - 申请效率的比较：
     栈由系统自动分配，速度较快。但程序员是无法控制的。
     堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

     

5. 现在有100个线程，一个数，初始值为0，每个线程都对其进行+10操作，为了保证最后的结果是1000，有什么手段？ 加锁，还有其他呢？信号量？

6. 线程用的锁是放在堆里还是栈里？

7. 现在有10个进程，要去初始化一个字典，只有一个进程能实现，怎么做？加锁？？放在哪里？如

   何实现？

8. 共享内存如何实现？

9. 说说进程通信方式

   （1）管道（pipe)：半双工的通信方式，单向流动，具有亲缘关系的进程

   （2）有名管道（named pipe)：半双工的通信方式，允许无亲缘关系进程间的通信

   （3）信号量（semophore)：计数器，控制多个进程对共享资源的访问。常作为一种锁机制，一   种同步手段

   （4）消息队列（message queue)：消息链表

   （5）信号（signal)：一种复杂的通信方式，用于通知和接受进程某个事件已经发生，是唯一一种异步通信机制。

   （6）共享内存（shared memory)：最快的IPC方式

   （7）套接字（Socket)：可用于不同主机间的进程通信

   线程通信方式：

   （1）锁机制：互斥锁、条件变量（原子方式）、读写锁

   （2）信号量机制

   （3）信号机制

10. 多线程 多进程 进程通信编程经验

11. 创建一个进程，应该调用什么函数？ fork() 或者 vfork()

12. fork和vfork区别

    vfork是先执行子进程，子进程与父进程共享代码、数据；

    fork不确定谁先执行，“写时拷贝”，子进程有自己的内存空间；

13. 同步的方法有哪些？

    互斥量、条件变量

14. 

15. 

    

    ​       

### 海量数据处理



### 算法与数据结构

1. （TX)题面

   小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为[m|S](m为一个整数且1<=m<=100)，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？

   输入描述

   输入第一行包含一个字符串s，代表压缩后的字符串。

   S的长度<=1000;

   S仅包含大写字母、[、]、|;

   解压后的字符串长度不超过100000;

   压缩递归层数不超过10层;

   样例输入

   HG[3|B[2|CA]]F

   样例输出

   HGBCACABCACABCACAF

   ```cpp
   #include <cstdio>
   #include <iostream>
   #include <string>
   #include <algorithm>
   #include <cstdlib>
   using namespace std;
   string helper(string s) {
       int n = s.length();
       int pos = s.find('[');
       if (pos == -1) return s;
       string ans = s.substr(0, pos);
       int p = s.find('|');
       int cnt = stoi(s.substr(pos + 1, p - pos - 1));
       int q = s.find_last_of(']');
       for (int i = 0; i < cnt; i++) ans += helper(s.substr(p + 1, q - p - 1));
       ans += s.substr(q + 1);
       return ans;
   }
   int main() {
       string s;
       cin >> s;
       cout << helper(s) << endl;
       system("pause");
       return 0;
   }
   ```

   

2. B树和B+树区别，优缺点

   ![image-20201009165144096](C:\Users\CXL\AppData\Roaming\Typora\typora-user-images\image-20201009165144096.png)

   区别：

   - B+树只有叶子节点会带有指向记录的指针（ROWID)，而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中；
   - B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

   B+树的优点：

   - 非叶子节点不会带上ROWID，这样一个块中可以容纳更多的索引项，一是可以降低树的高度，二是一个内部节点可以定位更多的叶子节点。
   - 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。

   B树的优点：

   ​       对于在内部节点的数据，可以直接得到，不必根据叶子节点来定位。

   B树和B+树相比二叉树做索引的优势：是多阶数，可以降低树的高度，减少IO次数。

3. 

4. 



### 数据库

1.  Mysql索引数据结构为什么是B+树，而不是hash/二叉树

   B+树比二叉树而言可以多路结构，降低树的高度，提高效率

   - 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；

   - 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；

   - 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；

   - 哈希索引也不支持多列联合索引的最左匹配规则；

   - B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

     - 利用Hash需要把数据全部加载到内存中，如果数据量大，是一件很消耗内存的事，而采用B+树，是基于按照节点分段加载，由此减少内存消耗。

     - 和业务场景有段，对于唯一查找（查找一个值），Hash确实更快，但数据库中经常查询多条数据，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。
       

2. 



### 网络编程、协议

1. select、poll、epoll的区别

2. 生产者消费者模式

3. TCP三次握手？四次挥手 

4. 如果接收方应用程序不接受数据，但发送方一直在发，从操作系统层面讲会发生什么？从TCP层面讲呢？ 

5. 使用TCP的应用层协议 

6. 套接字编程经验

7. HTTP首部字段

8. HTTP方法

9. GET和POST区别

10. POST一定会改变服务器的状态吗？

11. HTTP/1.1和HTTP/1.0的区别

12. HTTP/2.0和HTTP/1.x的区别

13. HTTP/2.0和HTTP/3.0 

14. HTTPS和HTTP的区别

15. HTTPS如何保证安全

16. HTTPS最后采用对称加密和而不是非对接加密？

17. 中间人攻击是什么？

18. 假设百度本来用的是HTTP，后来改成HTTPS，但人们已经习惯使用HTTP地址，浏览器保存的书签也是HTTP协议地址，如果百度希望用户使用HTTPS，应该怎么做？

19. 分布式编程经验

20. HTTP状态码

    分类：

    | 分类 | 分类描述                                       |
    | ---- | ---------------------------------------------- |
    | 1**  | 信息，服务器收到请求，需要请求者继续操作       |
    | 2**  | 成功，操作被成功接收并处理                     |
    | 3**  | 重定向，需要进一步的操作以完成请求             |
    | 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
    | 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

    - 200：请求成功
    - 301：资源（网页等）被永久转移到其他URL
    - 404：请求的资源（网页等）不存在
    - 500：内部服务器错误

21. 

### 大数据框架Spark、mapreduce编程



### Redis存储





### git操作

###  设计模式

### Go

1. Go协程比线程的优势
   - 成本低。堆栈只有若干kb，并且可以根据应用的需求进行增减；而线程必须制定堆栈的大小，其堆栈是固定不变的。
   - Go协程会复用数量更少的OS线程。即使程序有数以千计的Go协程，也可能只有一个线程。如果该线程的某一个Go协程发生了阻塞，那么系统会再创建一个OS线程，并把其余的Go协程都移动到这个新的OS线程。
   - Go协程使用信道进行通信。信道用于防止多个协程访问共享内存时发生竞态条件。信道可以看作Go协程之间通信的管道。
   
2. Go支持的通信方式

   管道、信号、Socket

3. 垃圾回收-三色标记法

​       主流的两类垃圾回收算法有两种，分别是追踪式垃圾回收算法和引用计数法。而三色标记法是属于追踪式垃圾回收算法的一种。

​       追踪式算法的核心思想是判断一个对象是否可达，因为一旦这个对象不可达就立刻被GC回收了。判断一个对象是否可达的方法是：第一步找出所有的全局变量和当前函数栈里的变量，标记为可达；第二步，从已经标记的数据开始，进一步标记它们可访问的变量，以此类推，专业术语叫传递闭包。

  三色标记法：

​       在三色标记法之前有一个算法叫Mark-And-Sweep（标记清扫），这个算法就是严格按照追踪式算法的思路来实现的。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是0，如果发现对象是可达的就会置为1，一步步下去就会呈现一个类似树状的结果，等标记步骤完成后，会将未被标记的对象统一清理，再次把所有的标记位设置为0方便下次清理。

这个算法最大的问题是GC执行期间需要把整个程序完全暂停，不能异步进行GC操作。因为在不同阶段标记清扫法的标志位0和1有不同的含义，那么新增的对象无论标记为什么都有可能意外删除这个对象。对实时性要求高的系统来说，这种需要长时间挂起的标记清扫法的不可接受的。所以就需要一个算法来解决GC运行时程序长时间挂起的问题，那就是三色标记法。

相比传统的标记清扫算法，三色标记最大的好处是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个 GC。

三色标记法很简单。首先将对象用三种颜色表示，分别是白色、灰色和黑色。最开始所有对象都是白色的，然后把其中全局变量和函数栈里的对象置为灰色。第二步把灰色的对象全部置为黑色，然后把原先灰色对象指向的变量都置为灰色，以此类推。等发现没有对象可以被置为灰色时，所有的白色变量就一定是需要被清理的垃圾了。

三色标记法因为多了一个白色的状态来存放不确定的对象，所以可以异步地执行。当然异步执行的代价是可能会造成一些遗漏，因为那些早先被标记为黑色的对象可能目前已经是不可达的了。所以三色标记法是一个 false negative（假阴性）的算法。

除了异步标记的优点，三色标记法掌握了更多当前内存的信息，因此可以更加精确地按需调度，而不用像标记清扫法那样只能定时执行。

4. 



### 开放性题目

1.  一堆服务器组织成完全图，能够互相 Ping, 找出测节点之间延迟的方式，要求 Ping 包数目尽可能少，而且各个节点流量尽可能均匀。