## 后台开发面试题目分类及总结

### C++问题

1.  C++11特性
    - 自动类型推导 auto
    - lambda匿名函数
    - for each遍历元素
    - {}初始化 vector
    - 右值引用(move)
2.  C++内存模型
3.  STL allocator实现
4.   C++ 四种强制类型转换
    * const_cast 
      - 常量指针被转化成非常量的指针，并且仍然指向原来的对象；
      - 常量引用被转换成非常量的引用，并且仍然指向原来的对象；
      - const_cast一般用于修改指针，如const char* p形式
    * static_cast
      - static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。
      - 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
      - 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。
      - static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)
      - 在c++ primer 中说道：c++ 的任何的隐式转换都是使用 *static_cast* 来实现。
    * dynamic_cast
      - *dynamic_cast*强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.
    *  reinterpret_cast
      - reinterpret_cast是强制类型转换符用来处理无关类型转换的，通常为操作数的位模式提供较低层次的重新解释！但是他仅仅是重新解释了给出的对象的比特模型，并没有进行二进制的转换！
      - reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。
5.  static 关键字的用法
    - 面向过程设计中的static
      - 静态全局变量：该变量在全局数据区分配内存；未经初始化的静态全局变量会被程序自动初始化为0；静态全局变量在声明它的整个文件是可见的，而在文件之外是不可见的。
      - 静态局部变量：该变量在全局数据区分配内存；静态局部变量在程序执行到该对象的声明处时被首次初始化，及以后的函数调用不再进行初始化；静态局部变量一般在声明初始化，如果没有显式初始化，会被程序自动初始化为0；始终驻留在全局数据区，直到程序运行结束。
      - 静态函数：不能被其他文件所用；其他文件中可以定义相同名字的函数，不会发生冲突。
    - 面向对象的static
      - 静态数据成员：所有对象共有；在全局数据区；不属于特定的类的对象，在没有产生类对象时其作用域就可见；静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其他全局名字冲突的可能性；可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能。
      - 静态成员函数：静态成员函数不能访问非静态成员函数和非静态数据成员
6.  

### Linux系统

1. 线程和进程的区别

2. 协程和线程区别

3. 进程空间分布

4. 堆和栈的区别

   - 堆和栈是内存分区中两个部分。栈区是由编译器自动分配和释放，存放函数的参数值，局部变量的值等；堆区一般有程序员分配释放，若程序员不释放，程序结束后可能由OS回收。

   - 申请方式：堆由程序员自己申请并指明大小，在C中malloc函数，如p1 = (char*)malloc(10);栈由系统自动分配，如声明在函数中一个局部变量int b;系统自动在栈中为b开辟空间。

   - 申请后系统的响应：栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则         将报异常提示栈溢出。堆区：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大 小，系统会自动的将多余的那部分重新放入空闲链表中。

   - 申请大小的限制：栈区：在Windows下,栈是向低地址扩展的数据结 构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是 一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

   - 申请效率的比较：
     栈由系统自动分配，速度较快。但程序员是无法控制的。
     堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

     

5.  现在有100个线程，一个数，初始值为0，每个线程都对其进行+10操作，为了保证最后的结果是1000，有什么手段？ 加锁，还有其他呢？信号量？

6. 线程用的锁是放在堆里还是栈里？

7. 现在有10个进程，要去初始化一个字典，只有一个进程能实现，怎么做？加锁？？放在哪里？如

   何实现？

8. 共享内存如何实现？

9. 说说进程通信方式

   （1）管道（pipe)：半双工的通信方式，单向流动，具有亲缘关系的进程

   （2）有名管道（named pipe)：半双工的通信方式，允许无亲缘关系进程间的通信

   （3）信号量（semophore)：计数器，控制多个进程对共享资源的访问。常作为一种锁机制，一   种同步手段

   （4）消息队列（message queue)：消息链表

   （5）信号（signal)：一种复杂的通信方式，用于通知和接受进程某个事件已经发生，是唯一一种异步通信机制。

   （6）共享内存（shared memory)：最快的IPC方式

   （7）套接字（Socket)：可用于不同主机间的进程通信

   线程通信方式：

   （1）锁机制：互斥锁、条件变量（原子方式）、读写锁

   （2）信号量机制

   （3）信号机制

10. 多线程 多进程 进程通信编程经验

11. 创建一个进程，应该调用什么函数？ fork() 或者 vfork()

12. fork和vfork区别

13. 

14. 

15. 

    

    ​       

### 海量数据处理



### 算法与数据结构



### 数据库

1.  Mysql索引数据结构为什么是B+树，而不是hash/二叉树

   B+树比二叉树而言可以多路结构，降低树的高度，提高效率

   - 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；

   - 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；

   - 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；

   - 哈希索引也不支持多列联合索引的最左匹配规则；

   - B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

     - 利用Hash需要把数据全部加载到内存中，如果数据量大，是一件很消耗内存的事，而采用B+树，是基于按照节点分段加载，由此减少内存消耗。

     - 和业务场景有段，对于唯一查找（查找一个值），Hash确实更快，但数据库中经常查询多条数据，这时候由于B+数据的有序性，与叶子节点又有链表相连，他的查询效率会比Hash快的多。
       

2. 



### 网络编程、协议

1. select、poll、epoll的区别
2. 生产者消费者模式
3. TCP三次握手？四次挥手 
4. 如果接收方应用程序不接受数据，但发送方一直在发，从操作系统层面讲会发生什么？从TCP层面讲呢？ 
5. 使用TCP的应用层协议 
6. 套接字编程经验
7. HTTP首部字段
8. HTTP方法
9. GET和POST区别
10. POST一定会改变服务器的状态吗？
11. HTTP/1.1和HTTP/1.0的区别
12. HTTP/2.0和HTTP/1.x的区别
13. HTTP/2.0和HTTP/3.0 
14. HTTPS和HTTP的区别
15.  HTTPS如何保证安全
16. HTTPS最后采用对称加密和而不是非对接加密？
17.  中间人攻击是什么？
18.  假设百度本来用的是HTTP，后来改成HTTPS，但人们已经习惯使用HTTP地址，浏览器保存的书签也是HTTP协议地址，如果百度希望用户使用HTTPS，应该怎么做？
19. 分布式编程经验

### 大数据框架Spark、mapreduce编程



### Redis存储





### git操作

###  设计模式

### Go

1. Go协程比线程的优势
   - 成本低。堆栈只有若干kb，并且可以根据应用的需求进行增减；而线程必须制定堆栈的大小，其堆栈是固定不变的。
   - Go协程会复用数量更少的OS线程。即使程序有数以千计的Go协程，也可能只有一个线程。如果该线程的某一个Go协程发生了阻塞，那么系统会再创建一个OS线程，并把其余的Go协程都移动到这个新的OS线程。
   - Go协程使用信道进行通信。信道用于防止多个协程访问共享内存时发生竞态条件。信道可以看作Go协程之间通信的管道。
2.  
3. 

### 开放性题目

1.  一堆服务器组织成完全图，能够互相 Ping, 找出测节点之间延迟的方式，要求 Ping 包数目尽可能少，而且各个节点流量尽可能均匀。