###                                                                                                                   算法刷题分类总结FAQ

<style>
    th, td {
        text-align: center;
        vertical-align: middle;
    }
    a {
        text-decoration: none;
    }
</style>
<table>
    <tr>
        <th>知识点</th>
        <th>题目</th>
        <th>难度及重要程度</th>
    </tr>
    <tr>
        <td rowspan="7">滑动窗口</td>
        <td><a href=https://leetcode-cn.com/problems/subarrays-with-k-different-integers>LC992. K个不同整数的子数组</a></td>
        <td>困难⭐⭐</td>
    </tr>
     <tr>
        <td><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">LC209. 长度最小的子数组</a></td>
         <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
     <tr>
         <td><a href="https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/">LC325. 和为K的最长子数组</a></td>
         <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
     <tr>
        <td><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">LC1004. 最大连续1的个数 III</a></td>
         <td>中等⭐⭐⭐⭐</td>
    </tr>
     <tr>
        <td><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">LC904. 水果成篮</a></td>
         <td>中等⭐⭐⭐⭐</td>
    </tr>
     <tr>
        <td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">LC3. 无重复字符的最长子串</a></td>
        <td>困难⭐⭐⭐</td>
    </tr>
     <tr>
         <td><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">LC424. 替换后的最长重复字符</a></td>
         <td>困难⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="10">双指针</td>
        <td><a href="https://leetcode-cn.com/problems/pairs-with-sum-lcci/">面试题16.24 数对和</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://www.lintcode.com/problem/paint-the-ceiling/description">Lintcode281. 粉刷天花板</a></td>
        <td>中等⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/two-sum/">LC1. 两数之和</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">LC26. 删除排序数组中的重复项</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">LC977. 有序数组的平方</a></td>
        <td>简单⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/3sum/">LC15. 三数之和</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/3sum-closest/">LC16. 最接近的三数之和</a></td>
        <td>中等⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/3sum-smaller/">LC259.	较小的三数之和</a></td>
        <td>中等⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">LC713. 乘积小于K的子数组</a></td>
        <td>中等⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/sort-colors/">LC75. 颜色分类</a></td>
        <td>中等⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="4">快慢指针</td>
        <td><a href="https://leetcode-cn.com/problems/linked-list-cycle/">LC141. 环形链表</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LC142. 环形链表 II</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/happy-number/">LC202. 快乐数</a></td>
        <td>简单⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">LC876. 链表的中间结点</a></td>
        <td>简单⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="3">合并区间</td>
        <td><a href="https://leetcode-cn.com/problems/merge-intervals/">LC56. 合并区间</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/insert-interval/">LC57. 插入区间</a></td>
        <td>困难⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/interval-list-intersections/">LC986. 区间列表的交集</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="4">循环排序</td>
        <td><a href="https://leetcode-cn.com/problems/missing-number/">LC268. 丢失的数字</a></td>
        <td>简单⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">LC448. 找到所有数组中消失的数字</a></td>
        <td>简单⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">LC287. 寻找重复数</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
       <td><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">LC442. 数组中重复的数据</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="3">翻转链表</td>
        <td><a href="https://leetcode-cn.com/problems/reverse-linked-list/">LC206. 反转链表</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">LC92. 反转链表 II</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">LC25. K 个一组翻转链表</a></td>
        <td>困难⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="6">树上的BFS</td>
        <td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LC102. 二叉树的层序遍历</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">LC103. 二叉树的锯齿形层次遍历</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">LC107. 二叉树的层次遍历 II</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">LC637. 二叉树的层平均值</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">LC111. 二叉树的最小深度</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/inorder-successor-in-bst/solution/">LC285
二叉搜索树中的顺序后继</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="5">树上的DFS</td>
        <td><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">LC124. 二叉树中的最大路径和</a></td>
        <td>困难⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/path-sum-ii/">LC113. 路径总和 II
</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">LC129. 求根到叶子节点数字之和</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/">LC1430. 判断给定的序列是否是二叉树从根到叶的路径</a></td>
        <td>中等⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/path-sum-iii/">LC437. 路径总和 III</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>LC
        <td rowspan="3">双堆类型</td>
        <td><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">LC295. 数据流的中位数</a></td>
        <td>困难⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/sliding-window-median/">LC480. 滑动窗口中位数</a></td>
        <td>困难⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/ipo/">LC502. IPO</a></td>
        <td>困难⭐</td>
    </tr>
    <tr>
        <td rowspan="6">子集类型（多重DFS)</td>
        <td><a href="https://leetcode-cn.com/problems/subsets/">LC78. 子集</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/subsets-ii/">LC90. 子集 II</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/permutations/">LC46. 全排列</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/letter-case-permutation/">LC784. 字母大小写全排列</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://www.jianshu.com/p/3a284d5709a0">FB面试题: Balanced Parentheses</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/generalized-abbreviation/">LC320. 列举单词的全部缩写</a></td>
        <td>困难⭐</td>
    </tr>
    <tr>
        <td rowspan="4">改造过的二分</td>
        <td><a href="https://www.prodevelopertutorial.com/order-agnostic-binary-search/">Order-Agnostic Binary Search</a></td>
        <td>简单⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">剑指11. 旋转数组的最小数字</a></td>
        <td>简单⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://segmentfault.com/a/1190000008598812">雅虎面试题:无限排序数组查找</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://blog.csdn.net/weixin_33743248/article/details/94052908">查找双调数组最大值</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="10">前K个系列</td>
        <td><a href="https://www.lintcode.com/problem/top-k-largest-numbers/description">Lintcode544. 前K大数</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://massivealgorithms.blogspot.com/2015/11/leetcode9-k.html">谷歌面试题: 前k大的和</a></td>
        <td>困难⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">LC973. 最接近原点的 K 个点</a></td>
        <td>中等⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode.com/discuss/interview-question/344677/Amazon-or-Online-Assessment-2019-or-Min-Cost-to-Connect-Ropes/">亚马逊面试题: Min Cost to Connect Ropes</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">LC347. 前 K 个高频元素</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">LC451. 根据字符出现频率排序</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">LC703. 数据流中的第 K 大元素</a></td>
        <td>简单⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">LC658. 找到 K 个最接近的元素</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://practice.geeksforgeeks.org/problems/maximum-distinct-elements-after-removing-k-elements/0">Maximum distinct elements after removing K elements </a></td>
        <td>简单⭐⭐⭐</td>
    </tr>
    <td><a href="https://leetcode-cn.com/problems/rearrange-string-k-distance-apart/solution/">LC358. K 距离间隔重排字符串</a></td>
    <td>困难⭐</td>
    <tr>
        <td rowspan="3">多路归并</td>
        <td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">LC23. 合并K个升序链表</a></td>
        <td>困难⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">LC378. 有序矩阵中第K小的元素</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/smallest-range-i/">LC908. 最小差值 I</a></td>
        <td>简单⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="4">0/1背包类型</td>
        <td><a href="https://www.lintcode.com/problem/backpack/description">LintCode92. 背包问题</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">LC416. 分割等和子集</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/target-sum/">LC494. 目标和</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">LC1049. 最后一块石头的重量 II</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td rowspan="6">拓扑排序</td>
        <td><a href="https://leetcode-cn.com/problems/course-schedule/">LC207. 课程表</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/task-scheduler/">LC621. 任务调度器</a></td>
        <td>中等⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://leetcode-cn.com/problems/course-schedule-iv/">LC1462. 课程安排 IV</a></td>
        <td>中等⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://www.lintcode.com/problem/alien-dictionary/description">LintCode
892. 外星人词典</a></td>
        <td>困难⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://www.lintcode.com/problem/topological-sorting/description">LintCode
127. 拓扑排序</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
    <tr>
        <td><a href="https://www.lintcode.com/problem/course-schedule-ii/description">LintCode
616. 安排课程</a></td>
        <td>中等⭐⭐⭐⭐⭐</td>
    </tr>
</table>






### Appendix  部分会员题目

**325.Maximum Sum Subarray of Size K（最大子数组和为k）**
Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn’t one, return 0 instead

**Note:**
The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.

**Example 1:**

```
Given nums = [1,-1,5,-2,3],k = 3,
return 4.(because the subarray [1,-1,5,-2] sums to 3 and is the longest
12
Given nums = [-2,-1,2,1], k = 1,
return 2.(because the subarray [-1,2] sums to 1 and is the longest
```

**code**

```cpp
class Solution {
    int maxSubArrayLen(vector<int>& nums, int K) {
        int len = 0, Sum = 0;
        unordered_map<int, int> mp;
        mp[0] = -1;
        for (int i = 0; i < nums.size(); i++) {
            Sum += nums[i];
            if (mp.count(Sum - K)) {
                len = max(len, i - mp[Sum - K]);
            }
            if (mp.count(Sum) == 0) mp[Sum] = i;
        }
        return len;
    }
}
```

**259. 较小的三数之和**

给定一个长度为 n 的整数数组和一个目标值 target，寻找能够使条件 nums[i] + nums[j] + nums[k] < target 成立的三元组  i, j, k 个数（0 <= i < j < k < n）。

```javascript
示例：
输入: nums = [-2,0,1,3], target = 2
输出: 2 
解释: 因为一共有两个三元组满足累加和小于 2:
     [-2,0,1]
     [-2,0,3]
进阶：是否能在 O(n2) 的时间复杂度内解决？
```

**code**

```cpp

```

**285. 二叉搜索树中的顺序后继**

给你一个二叉搜索树和其中的某一个结点，请你找出该结点在树中顺序后继的节点。

结点 p 的后继是值比 p.val 大的结点中键值最小的结点。

示例 1:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704225328716.png)

```cpp
输入: root = [2,1,3], p = 1
输出: 2
解析: 这里 1 的顺序后继是 2。
请注意 p 和返回值都应是 TreeNode 类型。
1234
```

示例 2:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200704225345110.png)

```cpp
输入: root = [5,3,6,2,4,null,null,1], p = 6
输出: null
解析: 因为给出的结点没有顺序后继，所以答案就返回 null 了。
 
注意:
假如给出的结点在该树中没有顺序后继的话，请返回 null
我们保证树中每个结点的值是唯一的
```

**code**

```cpp

```

Given a binary tree where each path going from the root to any leaf form a **valid sequence**, check if a given string is a **valid sequence** in such binary tree. 

We get the given string from the concatenation of an array of integers `arr` and the concatenation of all values of the nodes along a path results in a **sequence** in the given binary tree.

**Example 1:**

![img](https://leetcode.jp/wp-content/uploads/2020/05/leetcode_testcase_1.png)

```
Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,0,1]
Output: true
Explanation: 
The path 0 -> 1 -> 0 -> 1 is a valid sequence (green color in the figure). 
Other valid sequences are: 
0 -> 1 -> 1 -> 0 
0 -> 0 -> 0
```

**Example 2:**

![img](https://leetcode.jp/wp-content/uploads/2020/05/leetcode_testcase_2.png)

```
Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,0,1]
Output: false 
Explanation: The path 0 -> 0 -> 1 does not exist, therefore it is not even a sequence.
```

**Example 3:**

![img](https://leetcode.jp/wp-content/uploads/2020/05/leetcode_testcase_3.png)

```
Input: root = [0,1,0,0,1,0,null,null,1,0,0], arr = [0,1,1]
Output: false
Explanation: The path 0 -> 1 -> 1 is a sequence, but it is not a valid sequence.
```

**Constraints:**

- `1 <= arr.length <= 5000`
- `0 <= arr[i] <= 9`
- Each node’s value is between [0 – 9].

**code**

```cpp

```

**Facebook 面经题**

Given a String with parentheses, return a string with balanced parentheses by removing fewest characters possible. You cannot add anything to the string.
E.g.
balabce(“()”) -> “()”
balance(“)(“) -> “”
balance(“(((((()”) -> “()”
balance(“()(((()()”) -> “()()()”

**code**

```cpp

```

**Order-Agnostic Binary Search**

**Question:**

Given an array whose order of sorting is unknown and a key. You need to check if the key is present or not using binary search.

**Solution:**

As the question stated, we dont know the order of the array.

Our first step is to get to know the order of the array.

How do we do that?

Simple: We check the first and last element of the array.

If the first element is smaller than the last element, then it is in ascending order, else it is in descnding order.

**code**

```cpp
#include <iostream>
using namespace std;

int binary_search(int arr[], int start, int end, int key) 
{ 
    int ascending = 0;

    if (arr[start] < arr[end])
        ascending = 1;


    while (start <= end) 
    { 
        int mid = start + (end - start) / 2; 
  
        // Check if key is present at mid 
        if (arr[mid] == key) 
            return mid; 
  
        if(ascending == 1)
        {
            // If key greater, ignore left half 
            if (arr[mid] < key) 
                start = mid + 1; 
      
            // If key is smaller, ignore right half 
            else
                end = mid - 1; 

        } else {
            // If key greater, ignore right half 
            if (arr[mid] < key) 
                end = mid - 1; 
      
            // If key is smaller, ignore left half 
            else
                start = mid + 1; 
        }
    } 
  
    // if we reach here, then element was 
    // not present 
    return -1; 
} 
  
int main(void) 
{ 
    //descending order
    int arr[] = { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}; 
    int key = 2; 
    int size = sizeof(arr) / sizeof(arr[0]); 
    int result = binary_search(arr, 0, size - 1, key); 
    if(result == -1)
    {  
        cout << "Key is not present in array"<<endl;
    } else {
        cout << "Key is present at index " << result<<endl ;
    }


    //ascending order
    int arr_1[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 
    int key_1 = 2; 
    int size_1 = sizeof(arr) / sizeof(arr[0]); 
    int result_1 = binary_search(arr_1, 0, size_1 - 1, key_1); 
    if(result_1 == -1)
    {  
        cout << "Key is not present in array"<<endl;
    } else {
        cout << "Key is present at index " << result_1<<endl ;
    }

    return 0; 
} 
```

**雅虎面试题：从无限长的数组查找**![img](https://sponsor.segmentfault.com/lg.php?bannerid=0&campaignid=0&zoneid=25&loc=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008598812&referer=https%3A%2F%2Fwww.google.com%2F&cb=b84b3f562e)

You are given an infinite array A[] in which the first n cells contain integers in sorted order and the rest of the cells are filled with ∞. You are not given the value of n. Describe an algorithm that takes an integer x as input and finds a position in the array containing x, if such a position exists, in O(log n) time.
**意思：**
给定一个数组A[ ]，包含无限个元素，前n个元素是排好序的，后面的值全部是无穷大。找到给定的目标x，如果x存在于前n个元素中，返回其索引。
要求时间复杂度是logn.
例子：
{1,2,3,4,7,9,11,18,20,31,36,65,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE}
如果找24，则找不到，返回-1。
如果找31，则找到，返回其索引9。

**Solution:**
排好序的数组，并且查找复杂度logN,可以立即想到要用二分查找。

关键是这个无限大的数组，不知道右边的边界。所以要确定右边界，并且总体时间复杂度也不能超过logN。
logN 可以想象为树的层数的概念，每层节点数是2^i，这样子每次以该量级递增，则复杂度是logN.
那么使用位置1，2，4，8，16。。。依次判断数组的该位置是否是MAX_VALUE，碰到就停止。这样就可以保证log级别的复杂度找到边界。

**代码实现:**

```java
public class FindKIndexFromInfinteArray {
    public static int solution(int[] array, int target){
        int result = -1;
        // 处理边界与特殊值
        if(array == null || array.length == 0)    return result;
        if(array[0] == Integer.MAX_VALUE)    return result;
        else if(array[0] == target)    return 1;
        
        int i = 1;
        while(array[i] != Integer.MAX_VALUE){// 遇到MAX就停止
            if(array[i] == target)    return i;// 在循环中如果碰到刚好等于目标值，就直接返回
            i *= 2;//2，4，8，16，32。。。以指数级别上升
        }
        // 此时i定位到一个右边界，开始进行二分查找，从0到i
        result = binarySearch(array, target, 0, i);
        return result;
    }
    /** 二分查找*/
    private static int binarySearch(int[] array, int target, int low, int high) {
        int left = low, right = high - 1;
        /* 如果这里是 int right = n 的话，那么下面有两处地方需要修改，以保证一一对应：    
         * 1、下面循环的条件则是while(left < right)    
         * 2、循环内当array[middle]>value 的时候，right = mid 
         */
        while(left <= right){
            int mid = left + ((right - left) >> 1);
            if(array[mid] > target)        right = mid - 1;
            else if(array[mid] < target)    left = mid + 1;
            else    return mid;
        }
        return -1;
    }
    public static void main(String[] args) {
        int[] nums = {1,2,3,4,7,9,11,18,20,31,36,65,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE,Integer.MAX_VALUE};
        System.out.println(solution(nums, 31));
    }
}
```

**查找双调数组的最大值**

**question**

First, a bitonic array for this question is defined as one such that for some index `K` in an array of length N where 0 < K < N - 1 and 0 to K is a monotonically increasing sequence of integers, and K to N - 1 is a monotonically decreasing sequence of integers.

Example: [1, 3, 4, 6, 9, 14, 11, 7, 2, -4, -9]. It monotonically increases from 1 to 14, then decreases from 14 to -9.

Given a bitonic array and element x, find the index of x in ~2log(n) time.

**code**

```cpp
int bitonicSearch(int[] array, int key, int left, int right)
{
    if (left > right)
    {
        return -1;
    }
    int mid = (left + right) / 2;
    
    if (array[mid] < key)
    {
        // ascend
        if (array[mid] < array[mid + 1])
        {
            return bitonicSearch(array, key, mid + 1, right);    
        }
        // descend
        else
        {
            return bitonicSearch(array, key, left, mid - 1);
        }
    }
    else
    {
        int result = bisearch(array, key, left, mid);
        if (result == -1)
        {
            result = deBisearch(array, key, mid, right);
        }
        return result;
    }
}
```

**Maximum distinct elements after removing K elements** 

Given an array containing N elements. The task is to find maximum number of distinct elements after removing K elements from the array.

**Input:**
The first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case consists of two lines. First line of each test case contains two Integers N and K and the second line contains N space separated elements.

**Output:**
For each test case, print the maximum distinct elements after removing K elements in new line.

**Constraints:**
1<=T<=100
1<=K<=N<=106
1<=A[i]<=105

**Example:
Input:**
2
7 3
5 7 5 5 1 2 2
7 5
1 2 3 4 5 6 7
**Output:**
4
2

**Explanation:**

```
Input : A[] = {5, 7, 5, 5, 1, 2, 2}, K = 3
Output : 4
Remove 2 occurrences of element 5 and
1 occurrence of element 2.
```

```cpp

```

**[LeetCode] 358. K 距离间隔重排字符串**

**题目**

给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离至少为 k。

所有输入的字符串都由小写字母组成，如果找不到距离至少为 k 的重排结果，请返回一个空字符串 ""。

**示例**

示例 1：

```text
输入: s = "aabbcc", k = 3
输出: "abcabc" 
解释: 相同的字母在新的字符串中间隔至少 3 个单位距离。
```

示例 2:

```text
输入: s = "aaabc", k = 3
输出: "" 
解释: 没有办法找到可能的重排结果。
```

示例 3:

```text
输入: s = "aaadbbcc", k = 2
输出: "abacabcd"
解释: 相同的字母在新的字符串中间隔至少 2 个单位距离。
```

**code**

```python
'''
思路:
用堆

先统计每个单词个数
通过个数建立最大堆(从堆中弹出是个数最多的字母)
每次用个数最多的字母组成k个字符
依次循环下去
'''
class Solution:
    def rearrangeString(self, s: str, k: int) -> str:
        from collections import Counter
        import heapq
        if k <= 1: return s
        c = Counter(s)
        n = len(s)
        heap = [(-v, k) for k, v in c.items()]
        heapq.heapify(heap)
        res = ""
        while heap:
            tmp = []
            for _ in range(k):
                if not heap:return res if len(res) == n else ""
                num, alp = heapq.heappop(heap)
                num += 1
                res += alp
                if num != 0:
                    tmp.append((num, alp))
            for t in tmp:
                heapq.heappush(heap, t)
        return res
```

